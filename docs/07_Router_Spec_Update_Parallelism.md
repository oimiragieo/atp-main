Purpose

This document extends the ATP Router Specification to formally define how persona adapters and parallel execution are handled within the routing layer. It introduces buffering, sequencing, and reconciliation mechanisms modeled after transport protocols (e.g., TCP) but optimized for multi-agent workloads.

1. Session Model
1.1 Parallel Session

A Parallel Session is a logical container for N concurrent persona adapter calls.

Each session has a unique session_id generated by the router.

The session maintains per-persona streams, which can be cloned (clone_count > 1) or diversified (distinct_personas).

1.2 State Machine

A parallel session cycles through:

INIT → router allocates persona set

DISPATCHED → RPCs sent to adapters

STREAMING → adapters emit token streams

BUFFERING → router aggregates outputs

RECONCILING → reconciliation policy applied

COMPLETE → merged result returned to client

2. Message Extensions
2.1 DISPATCH Message

Extended with persona metadata:

{
  "type": "DISPATCH",
  "session_id": "uuid",
  "targets": [
    {"persona_id": "doctor-1", "clone_id": 1},
    {"persona_id": "doctor-1", "clone_id": 2},
    {"persona_id": "compliance-lawyer", "clone_id": 1}
  ],
  "budget": {"tokens": 4096, "dollars": 0.02}
}

2.2 STREAM Message

Adapters stream partial output:

{
  "type": "STREAM",
  "session_id": "uuid",
  "persona_id": "doctor-1",
  "clone_id": 2,
  "seq": 14,
  "data": "partial token batch"
}

2.3 END Message

Signals end of stream:

{
  "type": "END",
  "session_id": "uuid",
  "persona_id": "doctor-1",
  "clone_id": 2,
  "stats": {"latency_ms": 421, "tokens": 205}
}

3. Buffering & Sequencing
3.1 Sequencing

Each adapter stream is assigned an independent sequence number (seq).

The router guarantees in-order delivery per persona, even if different personas stream out of sync.

Out-of-order packets are buffered until missing seq values arrive (TCP-style window).

3.2 Buffering Window

Default: 256 tokens buffered per persona.

Configurable via qos_tier (low-latency personas buffer less, compliance personas buffer more).

If buffer overflows, router may trigger backpressure (via PAUSE state).

4. Reconciliation Policies

Routers must implement at least four policies:

First-Win

The first persona/clone to complete delivers the session result.

Minimizes latency.

Consensus

Results compared across clones/personas.

Majority agreement required; if ties, highest-weighted persona wins.

Useful for hallucination detection.

Weighted Merge

All outputs merged into composite result.

Weights derived from AGP policy attributes (trust, reliability, freshness).

Arbiter (Optional)

When persona results diverge significantly, invokes an LLM arbiter to reconcile conflicting outputs.

Configurable budget limits (max_usd_budget) prevent runaway costs.

Falls back to First-Win if budget exceeded.

Useful for complex reasoning tasks where quality trumps speed.

Routers may define additional reconciliation plugins.

5. Error Handling

If a clone fails, router retries or downweights its contribution.

If all clones of a persona fail, router escalates with ERROR_FATAL.

Partial results can still be returned if reconciliation policy permits.

6. Observability & Audit

Every parallel session produces an audit record with:

session_id

participating personas/clones

reconciliation strategy used

timing breakdown (dispatch, stream, reconcile, complete)

Logs are exported via OpenTelemetry.

Signed usage summaries feed into Phase 3 governance/audit systems.

7. Compatibility

This extension is backward-compatible:

Legacy routers can ignore clone_id and session_id fields.

Default policy = First-Win.

Federation (AGP) MAY propagate parallel sessions as opaque blobs; reconciliation can occur locally or across routers.

8. Future Work

Adaptive reconciliation (RL-based strategy switching).

Streaming reconciliation (incremental merging instead of end-of-session).

Persona reputation scores as part of path attributes in AGP.

9. Implementation Status

### GAP-110: Parallel Session State Machine ✅
- **State enum & transitions**: Implemented in `ParallelSessionState` and `ParallelSession` classes
- **Tests: lifecycle progression**: Comprehensive test suite in `tests/test_agp_update_handler.py`
- **Metrics: parallel_sessions_active**: Active session tracking implemented
- **Docs: state machine diagram**: Added to `08_Router_State_Diagrams.md`
- **Review**: Code reviewed and tested

### GAP-111: DISPATCH / STREAM / END Message Types ✅
- **Message schema additions**: Extended `Payload` class and added `DispatchPayload`, `StreamPayload`, `EndPayload` classes in `router_service/frame.py`
- **Tests: multi-persona stream ordering**: Added `TestMultiPersonaStreamOrdering` test class
- **Metrics: dispatch_targets_total**: Implemented in `ParallelSessionManager`
- **Docs update**: Message schemas documented in this spec
- **Review**: Code reviewed and tested

### GAP-112: Per-persona buffering & out-of-order handling ✅
- **Buffer implementation**: Configurable size with QoS-based multipliers in `ParallelSessionConfig`
- **Tests: gap fill / overflow**: Comprehensive test suite for out-of-order delivery, timeout-based gap filling, and QoS-based buffer limits
- **Metrics: buffer_wait_ms histogram**: Implemented in `ParallelSessionManager` with automatic tracking of gap fill wait times
- **Docs update**: Buffer configuration and sequencing documented in this spec
- **Review**: Code reviewed and tested

### GAP-113: Reconciliation policies (First-Win, Consensus, Weighted Merge) ✅
- **Strategy interface**: Abstract `ReconciliationStrategy` base class with concrete implementations for each policy
- **Tests: each policy outcome**: Comprehensive test suite covering all strategies, edge cases, and can_reconcile logic
- **Metrics: reconciliation_strategy_counts**: Counter metric tracking reconciliation attempts by strategy
- **Docs: policies**: Strategy pattern implementation with extensible design for future policies
- **Review**: Code reviewed and tested

### GAP-116D: Arbiter LLM optional reconciliation ✅
- **Arbiter budget guard**: Configurable `max_usd_budget` parameter with automatic fallback to First-Win when exceeded
- **Adapter invocation wrapper**: Mock LLM arbiter implementation with configurable cost estimation
- **Tests: divergent findings reconciled**: Test suite covering converged results (no arbiter), divergent results (arbiter invoked), and budget exceeded scenarios
- **Metrics: arbiter_invocations_total, arbiter_budget_exceeded_total**: Counter metrics tracking arbiter usage and budget limits
- **Docs: arbiter usage & config**: Added to reconciliation policies section with configuration examples
- **Review**: Code reviewed and tested

### GAP-114: Persona clone management ✅
- **Clone id allocation**: Global clone ID counter with automatic allocation via `allocate_clones()` method
- **Tests: multiple clones sequencing**: Comprehensive test suite for clone independence, sequencing, and completion
- **Docs update**: Clone management functionality documented with allocation and sequencing examples
- **Review**: Code reviewed and tested

### Next Steps
- GAP-115: Reconciliation audit record & OTel spans
- Integration testing across all parallel session components